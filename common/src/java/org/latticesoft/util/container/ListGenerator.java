/*
 * Copyright 2004 Senunkan Shinryuu
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created on May 29, 2006
 *
 */
package org.latticesoft.util.container;

import java.util.*;
import org.latticesoft.util.common.*;
import org.latticesoft.command.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * <p>
 * The ListGenerator generates a list of java bean based on 
 * the collection provided and populates the beans with the
 * values obtained from the collections
 * </p>
 * 
 * <p>
 * The values to be populated into the bean attributes are set
 * via the name attribute of the loopExpander object. The value
 * generated by the loopExpanded will be populated into the bean.
 * </p>
 * E.g.
 * <code>
 * 
 * </code>
 * 
 */
public class ListGenerator implements Command, Identity {
	private static final Log log = LogFactory.getLog(ListGenerator.class);
	
	// for identity
	private String name;
	private String id;

	// bean property
	private ArrayList attributeList = new ArrayList();
	private ArrayList beanList = new ArrayList();
	private String beanType;
	private Map beanAttributes = new HashMap();

	/** @return Returns the id. */
	public String getId() { return (this.id); }
	/** @param id The id to set. */
	public void setId(String id) { this.id = id; }
	/** @return Returns the name. */
	public String getName() { return (this.name); }
	/** @param name The name to set. */
	public void setName(String name) { this.name = name; }

	/** @return Returns the beanType. */
	public String getBeanType() { return (this.beanType); }
	/** @param beanType The beanType to set. */
	public void setBeanType(String type) { this.beanType = type; }
	
	/** @return Returns the beanList. */
	public List getBeanList() { return (this.beanList); }
	/** @param beanList The beanList to set. */
	public void setBeanList(List l) { this.beanList.addAll(l); }

	/** Add the default attribute to the bean */
	public void addBeanAttribute(Map map) {
		this.beanAttributes.putAll(map);
	}
	/** @return the bean's attribute */
	public Map getBeanAttributes() {
		return this.beanAttributes;
	}
	
	/**
	 * Add the command to the input list or output list generating command
	 */
	public boolean add(Object o) {
		if (o instanceof LoopExpander) {
			LoopExpander l = (LoopExpander)o;
			String name = l.getName();
			if (name != null) {
				this.attributeList.add(o);
				return true;
			}
		} else if (o instanceof Command){
			Command cmd = (Command)o;
			String name = null;
			// we get the name attribute
			if (o instanceof Identity) {
				name = ((Identity)cmd).getName();
			} else {
				name = (String)BeanUtil.getAttribute(o, "name");
			}
			if (name == null) {
				return false;
			}
			this.attributeList.add(o);
			return true;
		}
		return false;
	}

	public Object execute(Object o) throws CommandException {
		Collection c = this.generateList();
		if (o instanceof Map && this.name != null) {
			Map map = (Map)o;
			StringBuffer sb = new StringBuffer();
			sb.append(this.getName());
			sb.append(".").append("output");
			map.put(sb.toString(), c);
		}
		return c;
	}
	
	/** Generates the list based on the 2 loop parameters */
	public List generateList() {
		if (this.attributeList.size() == 0 || this.beanType == null) {
			return null;
		}
		
		// 1st we generate the collection from each of attributes's
		// command and stored in a map of name (key) to collection (value)
		
		OrderedMap omap = new OrderedMap();
		List l = null;
		String key = null;
		Command cmd = null;
		int size = 0;
		List referenceList = null; // input list
		//Integer theSize = null;
		for (int i=0; i<this.attributeList.size(); i++) {
			key = null;
			cmd = null;
			Object o = attributeList.get(i);
			if (o instanceof Command) {
				cmd = (Command)o;
			}
			// if its identity we use id else we try to use name attribute
			if (o instanceof Identity) {
				Identity id = (Identity)o;
				key = id.getName();
			}
			if (key == null) {
				key = (String)BeanUtil.getAttribute(o, "name");
			}
			if (key == null) {
				key = (String)BeanUtil.getAttribute(o, "id");
			}

			// now the key is valid we get the collection
			// we pass in the previous collection so that it knows
			// how many to limit the generate at 
			if (key != null && cmd != null) {
				Object res = cmd.execute(referenceList);
				if (res instanceof List) {
					l = (List)res;
				} else {
					continue;
				}
			}
			// remember the size of the collection
			if (i == 0) {
				size = l.size();
				//theSize = new Integer(size);
				referenceList = l;
			}
			// to add the the map, we must 1st make sure that the key is valid
			// the collection is not null and collection has size equals to 1st
			// collection's size
			if (key != null && l != null && l.size() == size) {
				omap.put(key, l);
				l = null;
			} else {
if (log.isInfoEnabled()) { log.info("Not added: " + name + " size: " + l.size()); }
			}
		}

		// now we loop thru the collections and generate list of map
		// containing each of the collection's value and the name
		// and create the corresponding bean
		Map map = new HashMap();
		Object value = null;
		for (int i=0; i<size; i++) {
			map.clear();
			Object bean = ClassUtil.newInstance(this.beanType);
			map.putAll(this.beanAttributes);

			Iterator iter = omap.keySet().iterator();
			while (iter.hasNext()) {
				key = (String)iter.next();
				l = (List)omap.get(key);
				value = l.get(i); 
				if (key != null && value != null) {
					map.put(key, value);
				}
			}
			MiscUtil.populateObject(bean, map);
			this.beanList.add(bean);
		}
		return this.beanList;
	}
	
	/**
	 * Converts the class in a string form
	 * @returns the class in a string form.
	 */
	public String toString() {
		return StringUtil.formatObjectToString(this);
	}
	
	public static void main(String[] args) {
		PropertyMap.singletonize();
		LoopExpander lp1 = new LoopExpander();
		LoopExpander lp2 = new LoopExpander();
		LoopExpander lp3 = new LoopExpander();
		
		lp1.setFormat("http://www.google.com?haha=#{i}");
		lp1.add("#{i}|000|1|8");
		lp1.setName("name");
		
		lp2.setFormat("C:/Temp/#{i}.jpg");
		lp2.add("#{i}|000|1|-1");
		lp2.setName("message");
		
		lp3.setFormat("Hahah#{i}.jpg");
		lp3.add("#{i}|00000|1|-1");
		lp3.setName("format");
		
		ListGenerator gen = new ListGenerator();
		gen.add(lp1);
		gen.add(lp2);
		gen.add(lp3);
		gen.setBeanType("org.latticesoft.util.common.TestBean");
		
		Collection c = gen.generateList();
		Iterator iter = c.iterator();
		while (iter.hasNext()) {
			Object iterObj = iter.next();
			if (iterObj != null) {
				System.out.println(iterObj);
			}
		}
	}
}
